#include <algorithm>
#include <atomic>
#include <iterator>
#include <unordered_map>
#include <vector>
using namespace std;

// The segment size of this structure.
// Tune this based on the number of sequential elements typically updated.
// This should probably be computed based on cache line size, but we need to know how to guarantee alignment.
// TODO: size and capacity are special cases. Give them each a segment size of 1 to reduce contention.
const unsigned int SEG_SIZE = 8;

// Use this typedef to quickly change what type of objects we're working with.
// We should ideally have a more permanent (and more flexible) solution to this. Perhpas just make these pointers?
typedef int VAL;

// This reserved value indicates that a value cannot be set by a read or write here.
const VAL UNSET = INT32_MIN;

// A standard, user-generated operation.
struct Operation
{
    // A list of all operation types supported within a transaction.
    enum OpType
    {
        // Write to a position relative to the current size.
        // Ignores bounds checking, since size reading must be part of the transaction.
        pushBack,
        // Read from a position relative to the current size.
        // Ignores bounds checking, since size reading must be part of the transaction.
        popBack,
        // Read capacity, then expand if need be.
        reserve,
        // Read at an absolute position in the vector.
        // Can fail bounds checking.
        read,
        // Write at an absolute position in the vector.
        // Can fail bounds checking.
        write,
        // Simillar to read, but always at the szie index (probably 1?).
        // Returned answer can be offset by a transaction's push and pop ops.
        size
    };

    // The type of operation being performed.
    OpType type;
    // Only used for read and write.
    unsigned int index;
    // Only used for push and write.
    // TODO: However, pop implicitly writes an unset value for bounds checking.
    VAL val;
    // Only used for size.
    size_t offset;
    // The return value for this operation.
    // Only used for read and pop.
    VAL ret;
};

// This is the descriptor generated by the programmer.
// This will be converted into an internal transaction to run on the shared datastructure.
struct Desc
{
    // The status of a transaction must be one of these.
    enum TxStatus
    {
        active,
        committed,
        aborted
    };

    // The number of operations in the transaction.
    unsigned int size = 0;
    // The status of the transaction.
    std::atomic<TxStatus> status;
    // An array of the operations themselves.
    Operation *ops;

    // Create a descriptor object.
    // ops:     An array of operations. Will use the data directly, rather than copying, so don't deallocate this.
    // size:    The number of operations in the operations array.
    Desc(unsigned int size, Operation *ops)
    {
        this->size = size;
        // Transactions are always active at start.
        status.store(active);
        this->ops = ops;
        /*
        // Array copying logic.
        this->ops = new Operation[size];
        std::copy(std::begin(ops), std::end(ops), std::begin(this->ops));
        */
        return;
    }
    ~Desc()
    {
        //delete ops;
        return;
    }
};

// TODO: Make this work properly.
// All transactions are converted into a read/write set before modifying the vector.
class RWSet
{
  public:
    class RWOperation
    {
      public:
        // TODO: We should be more fine-grained than this. Are these bounds checked reads and writes?
        bool read;
        bool write;
        int val;
        // Keep track of the last write operation to handle internally matching pushes and pops.
        Operation *lastWriteOp;
        // Keep a list of operations that want to read the old value.
        std::vector<Operation *> readList;

        RWOperation()
        {
            read = false;
            write = false;
            val = 0;
            lastWriteOp = NULL;
        }
    };

    // Map vector locations to read/write operations.
    // Used for absolute reads/writes.
    // TODO: Placing operations in this allocates memory.
    unordered_map<int, RWOperation> operations;

    // Create a RWSet based on the provided transaction.
    // Returns NULL if the transaction fails locally.
    void RWSet(Desc *descriptor)
    {
        // Determine what type of operations are contained in the transaction.
        // Knowing this allows us to optimize the transaction.
        // We can reduce contention by only locking size if push, pop, or size calls occur.
        // We can reduce overhead by modifying rather than recreating the whole transaction.
        bool hasPushPop = false;
        bool hasReadWrite = false;
        bool hasReserve = false;
        bool hasSize = false;
        for (int i = 0; i < descriptor->size; i++)
        {
            switch (descriptor->ops[i].type)
            {
            case pushBack:
            case popBack:
                hasPushPop = true;
                break;
            case read:
            case write:
                hasReadWrite = true;
                break;
            case reserve:
                hasReserve = true;
                break;
            case size:
                hasSize = true;
                break;
            default:
                // Unexpected operation type found.
                break;
            }
        }

        // Special case: Will delay a size read to resolve from a list of offsets.
        if (hasPushPop && !hasReadWrite)
        {
            // Get the min and max push and pop locations to determine our area of influence.
            int max = 0, min = 0, pos = 0;
            for (size_t i = 0; i < descriptor->size; i++)
            {
                switch (descriptor->ops[i].type)
                {
                case pushBack:
                    pos++;
                    break;
                case popBack:
                    pos--;
                    break;
                }

                if (pos > max)
                {
                    pos = max;
                }
                if (pos < min)
                {
                    pos = min;
                }
            }
            // Min and max tell us how far we pushed in or popped out of the stack.
            // Use these values to create an array of changes.
            // Note: The "0 point" is at index min.
            RWOperation *operationsList = new RWOperation[min + max];
            // Reset our position to keep track of where our push and pop ops go.
            pos = 0;
            // Go through every operation in the transaction, in order.
            for (size_t i = 0; i < descriptor->size; i++)
            {
                Operation *op = &descriptor->ops[i];
                switch (op->type)
                {
                case write:
                case read:
                    // This shouldn't be possible.
                    assert(0);
                    break;
                case pushBack:
                    // TODO: Ensure that this array index will never go out of bounds.
                    RWOperation *rwop = &operationsList[pos + min];
                    rwop->write = true;
                    rwop->lastWriteOp = op;
                    pos++;
                    break;
                case popBack:
                    pos--;
                    // TODO: Ensure that this array index will never go out of bounds.
                    RWOperation *rwop = &operationsList[pos + min];
                    if (rwop.lastWriteOp != NULL)
                    {
                        op->ret = rwop->lastWriteOp->val;
                    }
                    else
                    {
                        rwop->read = true;
                        // Add the operation to the read list.
                        rwop->readList.push_back(op);
                        // Also write an unset here to prevent future uncaught reads or writes.
                        rwop->write = true;
                        rwop->lastWriteOp = op;
                    }
                case size:
                    // We have to associate an offset for this size, based on internal pushes and pops.
                    // Use this offset later when we actually get the size.
                    op->offset = pos;
                case reserve:
                    // Reserve will be done at the beginning of the transaction to prevent needless extra reserves.
                    // Keep track of the largest reserve request.
                    // TODO: Store this in the RWSet somewhere?
                default:
                    break;
                }
            }
        }
        // Special case: Will not read size.
        // Use special bounds checking instead.
        else if (!hasPushPop && !hasSize)
        {
            // Go through every operation in the transaction, in order.
            for (size_t i = 0; i < descriptor->size; i++)
            {
                Operation *op = &descriptor->ops[i];
                switch (op->type)
                {
                case pushBack:
                case popBack:
                case size:
                    // This shouldn't be possible.
                    assert(0);
                    break;
                // Reserve is essentially a special case for write.
                case reserve:
                    RWOperation *rwop = operations[Vector::CAPACITY];
                    rwop->write = true;
                    rwop->lastWriteOp = op;
                    break;
                case write:
                    RWOperation *rwop = operations[op->index];
                    // We must also read this element, for proper bounds checking.
                    rwop->read = true;
                    rwop->write = true;
                    rwop->lastWriteOp = op;
                    break;
                case read:
                    RWOperation *rwop = operations[op->index];
                    // Match this read with the latest write in the transaction.
                    if (rwop.lastWriteOp != NULL)
                    {
                        op->ret = rwop->lastWriteOp->val;
                        // This shouldn't be possible, since we don't explicitly directly unset.
                        if (op->ret == UNSET)
                        {
                            // The transaction fails.
                            descriptor->status = Desc::aborted;
                            return NULL;
                        }
                    }
                    else
                    {
                        rwop->read = true;
                        // Add the operation to the read list.
                        rwop->readList.push_back(op);
                    }
                    break;
                default:
                    break;
                }
            }

            // TODO: Attempt to create page segments based on the generated RWOperation.
        }
        // Slow, general approach.
        // Supports all operation types.
        // TODO
        else
        {
            // TODO: Get the size at the beginning and use it to resolve all relative operations.
            // May cause a lot of work to repeat if it fails.
            // Go through every operation in the transaction, in order.
            for (size_t i = 0; i < descriptor->size; i++)
            {
                Operation *op = &descriptor->ops[i];
                switch (op->type)
                {
                case pushBack:
                case popBack:
                case size:
                    // This shouldn't be possible.
                    assert(0);
                    break;
                // Reserve is essentially a special case for write.
                case reserve:
                    RWOperation *rwop = operations[Vector::CAPACITY];
                    rwop->write = true;
                    rwop->lastWriteOp = op;
                    break;
                case write:
                    RWOperation *rwop = operations[op->index];
                    // We must also read this element, for proper bounds checking.
                    rwop->read = true;
                    rwop->write = true;
                    rwop->lastWriteOp = op;
                    break;
                case read:
                    RWOperation *rwop = operations[op->index];
                    // Match this read with the latest write in the transaction.
                    if (rwop.lastWriteOp != NULL)
                    {
                        op->ret = rwop->lastWriteOp->val;
                        // This shouldn't be possible, since we don't explicitly directly unset.
                        if (op->ret == UNSET)
                        {
                            // The transaction fails.
                            descriptor->status = Desc::aborted;
                            return NULL;
                        }
                    }
                    else
                    {
                        rwop->read = true;
                        // Add the operation to the read list.
                        rwop->readList.push_back(op);
                    }
                    break;
                default:
                    break;
                }
            }
        }
    }
};

// A delta update page.
class Page
{
  public:
    // This bitset keeps track of whether or not an element was read from or written to by this transaction.
    typedef struct Bitset
    {
        bool read = 0;
        bool write = 0;
    } Bitset;

    // The number of elements being updated by this page.
    unsigned int size;
    // A list of what modifications this transaction performs.
    // TODO: Compress this down to a handful of bits per element for space savings.
    Bitset *bitset;
    // A contiguous list of updated values.
    VAL *newVal;
    // A contiguous list of old values.
    // We need these in case the associated transaction aborts.
    VAL *oldVal;
    // A pointer to the transaction associated with this page.
    Desc *transaction;
    // A pointer to the next page in the delta update list for this segment.
    std::atomic<Page *> next;

    // Constructor that initializes a segment based on length.
    Page(unsigned int size)
    {
        this->size = size;
        bitset = new Bitset[SEG_SIZE];
        newVal = new VAL[size];
        oldVal = new VAL[size];
        return;
    }

    // A full constructor.
    // TODO: Point to a modified descriptor instead?
    Page(Desc *transaction, Page *page)
    {
        Page(transaction->size);
        next.store(page);
        this->transaction = transaction;
        return;
    }

    // Default constructor.
    // Can be used for consolidation or initialization.
    Page()
    {
        Page(SEG_SIZE);
        next.store(NULL);
        this->transaction = NULL;
        return;
    }

    // Always deallocate our dynamic memory.
    ~Page()
    {
        if (bitset != NULL)
        {
            delete bitset;
        }
        if (newVal != NULL)
        {
            delete newVal;
        }
        if (oldVal != NULL)
        {
            delete oldVal;
        }
    }
};